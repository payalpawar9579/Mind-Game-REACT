{"ast":null,"code":"// branchAndBound.js\n\n/**\n * Branch and Bound algorithm for optimal bin-packing\n * Given a set of values and bin capacity, it finds an optimal distribution\n */\n\n// Utility function to calculate the sum of a bin\nconst calculateBinSum = bin => bin.reduce((sum, item) => sum + item.value, 0);\nfunction branchAndBound(values, binCapacity) {\n  const bins = [[]];\n  const solutions = [];\n  let optimalSolution = null;\n  function placeValue(index) {\n    if (index >= values.length) {\n      // If all values are placed, add this to solutions and check if it's optimal\n      solutions.push([...bins.map(bin => [...bin])]);\n\n      // Calculate score (total sum) of current solution\n      const currentScore = bins.reduce((acc, bin) => acc + calculateBinSum(bin), 0);\n      if (!optimalSolution || currentScore > optimalSolution.score) {\n        optimalSolution = {\n          solution: [...bins.map(bin => [...bin])],\n          score: currentScore\n        };\n      }\n      return;\n    }\n\n    // Try placing the current value in each bin\n    const currentValue = values[index];\n    for (let i = 0; i < bins.length; i++) {\n      const bin = bins[i];\n      if (calculateBinSum(bin) + currentValue.value <= binCapacity) {\n        bin.push(currentValue);\n        placeValue(index + 1);\n        bin.pop();\n      }\n    }\n\n    // If all current bins are full, create a new bin and place the current value there\n    bins.push([currentValue]);\n    placeValue(index + 1);\n    bins.pop();\n  }\n  placeValue(0);\n\n  // Return the optimal solution found by the Branch and Bound algorithm\n  return optimalSolution;\n}\nexport default branchAndBound;","map":{"version":3,"names":["calculateBinSum","bin","reduce","sum","item","value","branchAndBound","values","binCapacity","bins","solutions","optimalSolution","placeValue","index","length","push","map","currentScore","acc","score","solution","currentValue","i","pop"],"sources":["/Users/payal/Desktop/bin-picking/src/components/branchAndBound.js"],"sourcesContent":["// branchAndBound.js\n\n/**\n * Branch and Bound algorithm for optimal bin-packing\n * Given a set of values and bin capacity, it finds an optimal distribution\n */\n\n// Utility function to calculate the sum of a bin\nconst calculateBinSum = (bin) => bin.reduce((sum, item) => sum + item.value, 0);\n\nfunction branchAndBound(values, binCapacity) {\n  const bins = [[]];\n  const solutions = [];\n  let optimalSolution = null;\n\n  function placeValue(index) {\n    if (index >= values.length) {\n      // If all values are placed, add this to solutions and check if it's optimal\n      solutions.push([...bins.map((bin) => [...bin])]);\n\n      // Calculate score (total sum) of current solution\n      const currentScore = bins.reduce((acc, bin) => acc + calculateBinSum(bin), 0);\n      if (!optimalSolution || currentScore > optimalSolution.score) {\n        optimalSolution = { solution: [...bins.map((bin) => [...bin])], score: currentScore };\n      }\n      return;\n    }\n\n    // Try placing the current value in each bin\n    const currentValue = values[index];\n    for (let i = 0; i < bins.length; i++) {\n      const bin = bins[i];\n      if (calculateBinSum(bin) + currentValue.value <= binCapacity) {\n        bin.push(currentValue);\n        placeValue(index + 1);\n        bin.pop();\n      }\n    }\n\n    // If all current bins are full, create a new bin and place the current value there\n    bins.push([currentValue]);\n    placeValue(index + 1);\n    bins.pop();\n  }\n\n  placeValue(0);\n\n  // Return the optimal solution found by the Branch and Bound algorithm\n  return optimalSolution;\n}\n\nexport default branchAndBound;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAMA,eAAe,GAAIC,GAAG,IAAKA,GAAG,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,GAAGC,IAAI,CAACC,KAAK,EAAE,CAAC,CAAC;AAE/E,SAASC,cAAcA,CAACC,MAAM,EAAEC,WAAW,EAAE;EAC3C,MAAMC,IAAI,GAAG,CAAC,EAAE,CAAC;EACjB,MAAMC,SAAS,GAAG,EAAE;EACpB,IAAIC,eAAe,GAAG,IAAI;EAE1B,SAASC,UAAUA,CAACC,KAAK,EAAE;IACzB,IAAIA,KAAK,IAAIN,MAAM,CAACO,MAAM,EAAE;MAC1B;MACAJ,SAAS,CAACK,IAAI,CAAC,CAAC,GAAGN,IAAI,CAACO,GAAG,CAAEf,GAAG,IAAK,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC,CAAC;;MAEhD;MACA,MAAMgB,YAAY,GAAGR,IAAI,CAACP,MAAM,CAAC,CAACgB,GAAG,EAAEjB,GAAG,KAAKiB,GAAG,GAAGlB,eAAe,CAACC,GAAG,CAAC,EAAE,CAAC,CAAC;MAC7E,IAAI,CAACU,eAAe,IAAIM,YAAY,GAAGN,eAAe,CAACQ,KAAK,EAAE;QAC5DR,eAAe,GAAG;UAAES,QAAQ,EAAE,CAAC,GAAGX,IAAI,CAACO,GAAG,CAAEf,GAAG,IAAK,CAAC,GAAGA,GAAG,CAAC,CAAC,CAAC;UAAEkB,KAAK,EAAEF;QAAa,CAAC;MACvF;MACA;IACF;;IAEA;IACA,MAAMI,YAAY,GAAGd,MAAM,CAACM,KAAK,CAAC;IAClC,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACK,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACpC,MAAMrB,GAAG,GAAGQ,IAAI,CAACa,CAAC,CAAC;MACnB,IAAItB,eAAe,CAACC,GAAG,CAAC,GAAGoB,YAAY,CAAChB,KAAK,IAAIG,WAAW,EAAE;QAC5DP,GAAG,CAACc,IAAI,CAACM,YAAY,CAAC;QACtBT,UAAU,CAACC,KAAK,GAAG,CAAC,CAAC;QACrBZ,GAAG,CAACsB,GAAG,CAAC,CAAC;MACX;IACF;;IAEA;IACAd,IAAI,CAACM,IAAI,CAAC,CAACM,YAAY,CAAC,CAAC;IACzBT,UAAU,CAACC,KAAK,GAAG,CAAC,CAAC;IACrBJ,IAAI,CAACc,GAAG,CAAC,CAAC;EACZ;EAEAX,UAAU,CAAC,CAAC,CAAC;;EAEb;EACA,OAAOD,eAAe;AACxB;AAEA,eAAeL,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}